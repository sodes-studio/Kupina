module.exports = function Kupina( b ) {
	var c, G, i, j, t, L, W, col, row, high ;
	if( ! b )  throw "Hash size undefined" ; 
	// hash (block) size
	if( b < 8 || b > 1024 ) throw "Invalid hash size" ; 
    if( b <= 256 ) {
		L = 512 ;  // internal state length
		t = 10  ;  // iteration count
		c = 8   ;  // columns in matrix		
	}
	else {
		L = 1024 ;		
		t = 14 ; 
		c = 16 ;
	}

    /**
     * Message hash (digest) in hexadecimal form
     * @param {*} message 
     * @param {string} mode "HEX"(default) "STR" "UTF8"
     * @returns string with hash
     */
    this.digest = function( message, mode = "HEX" ) {
		if( mode == "HEX" ) {
			
			return procHex( message ) ;
		}
		else if( mode == "STR" ) {
				
			return procStr( message ) ;
		}
		else if( mode == "UTF8" ) {
			return procUtf8( message ) ;
		}
		else {
			throw "Mode '" + mode + "' unsupported" ;
		}
	}

    const procHex = function( message ) {
        init() ;
		let bitLength = message.length * 4 ;		
		for( let b = 0; b < message.length; ++b ) {
			appendHex( message.charAt( b ) ) ;
		}
		appendHex( '8' ) ;
		if( freeBits() < 96 ) {
			W = hv() ;
			for( j = 0; j < c; ++j ) {
				G[ j ]  = [ 0, 0, 0, 0, 0, 0, 0, 0 ] ;
			}
		}
		writeSize( bitLength ) ;
		W = hv() ;
		return rln() ;
	}

	const procStr = function( message ) {
        init() ;
		const bitLength = message.length * 16 ;		
		var pos = 0 ;
		while( pos < message.length ) {
			let sym = message.charCodeAt( pos ) ;
			appendByte( ( sym >> 8 ) & 0xFF ) ;
			appendByte( sym  & 0xFF ) ;
			++pos ;
		}
		appendByte( 0x80 ) ;
		if( freeBits() < 96 ) {
			W = hv() ;
			for( j = 0; j < c; ++j ) {
				G[ j ]  = [ 0, 0, 0, 0, 0, 0, 0, 0 ] ;
			}
		}
		writeSize( bitLength ) ;
		W = hv() ;
		return rln() ;
	}

	const init = function() {
		G  = [ ] ;
		W = [ ] ;
		for( j = 0; j < c; ++j ) {
			G[ j ] = [ 0, 0, 0, 0, 0, 0, 0, 0 ] ;
			W[ j ] = [ 0, 0, 0, 0, 0, 0, 0, 0 ] ;
		}
		if( L == 512 ) {
			W[0][0] = 0x40 ;
		}
		else {
			W[0][0] = 0x80 ;
		}
		col = 0 ;
		row = 0 ;
		high = true ;
	}

	toString = function( matrix = G ) {
		ret = "" ; 
		for( j = 0; j < c; ++j ) {
			if( j == c / 2 ) ret += "<br/>" ; 
			for( i = 0; i < 8; ++i ) {
				if( matrix[ j ][ i ] < 16 )
					ret += '0' ; 
				ret += matrix[ j ][ i ].toString( 16 ) ;
			}
		}
		return ret ;
	}    

	const transform0 = function( matrix = G ) {
		var G1 = [] ;
		var G2 = [] ;
		for( j = 0; j < c; ++j ) {
			G1[ j ] = [] ;
			G2[ j ] = [] ;
			for( i = 0; i < 8; ++i ) {
				G1[ j ][ i ] = 0 ;
				G2[ j ][ i ] = matrix[ j ][ i ] ;
			}
		}
		for( let n = 0; n < t; ++n ) {
			for( j = 0; j < c; ++j ) {
				G2[ j ][ 0  ] ^= ( j << 4 ) ^ n ;  // kappa
				for( i = 0; i < 8; ++i ) {
					G1[ ( j + shift[ i ] ) & ( c - 1 ) ][ i ] = S[ i ][ G2[ j ][ i ] ] ;						
				}
			}
			// psi
			for( j = 0; j < c; ++j ) {
				for( i = 0; i < 8; ++i ) {
					let acc = 0 ;
					for(let k = 0; k < 8; ++k ) {
						acc ^= M( v[ ( k - i + 8 ) & 7 ], G1[ j ][ k ] ) ;
					}
					G2[ j ][ i ] = ( acc & 0xFF ) ;
				}
			}
		}
		return G2 ;
	}

	const transform1 = function( matrix = G ) {
		var G1 = [] ;
		var G2 = [] ;
		for( j = 0; j < c; ++j ) {
			G1[ j ] = [] ;
			G2[ j ] = [] ;
			for( i = 0; i < 8; ++i ) {
				G1[ j ][ i ] = 0 ;
				G2[ j ][ i ] = matrix[ j ][ i ] ;
			}
		}
		for( let n = 0; n < t; ++n ) {
			for( j = 0; j < c; ++j ) {
				var dz = [ 243, 240, 240, 240, 240, 240, 240, ( ( ( c - 1 - j ) << 4 ) ^ n ) & 0xFF ] ;
				let carry_over = 0 ;
				for( i = 0; i < 8; ++i ) {
					G2[ j ][ i ] = G2[ j ][ i ] + dz[ i ] + carry_over ;
					if( G2[ j ][ i ] > 0xFF ) {
						G2[ j ][ i ] &= 0xFF ;
						carry_over = 1;
					}
					else carry_over = 0;
				}
			}		
			for( j = 0; j < c; ++j ) {
				for( i = 0; i < 8; ++i ) {
					G1[ ( j + shift[ i ] ) & ( c - 1 ) ][ i ] = S[ i ][ G2[ j ][ i ] ] ;	
				}
			}
			// psi
			for( j = 0; j < c; ++j ) {
				for( i = 0; i < 8; ++i ) {
					let acc = 0 ;
					for(let k = 0; k < 8; ++k ) {
						acc ^= M( v[ ( k - i + 8 ) & 7 ], G1[ j ][ k ] ) ;
					}
					G2[ j ][ i ] = ( acc & 0xFF ) ;
				}
			}
		}
		return G2 ;
	}

	const hv = function( m = G ) {
		var h = [] ;
		for( j = 0; j < c; ++j ) {
			h[j] = [] ;
			for( i = 0; i < 8; ++i ) {
				h[j][i] = W[j][i] ^ m[j][i] ;
			}
		}
		let t0 = transform0(h) ;
		let t1 = transform1() ;
		for( j = 0; j < c; ++j ) {
			for( i = 0; i < 8; ++i ) {
				h[j][i] = t0[j][i] ^ t1[j][i] ^ W[j][i] ;
			}
		}
		return h ;
	}

	const rln = function() {
		let t0 = transform0( W ) ;
		for( j = 0; j < c; ++j ) {
			for( i = 0; i < 8; ++i ) {
				G[ j ][ i ] = t0[ j ][ i ] ^ W[ j ][ i ] ;
			}
		}
		// return last b bit from G
		let si = ( L - b ) / 8 % 8 ;  // start i
		let sj =  ( ( L - b ) - si * 8 ) / 8 / 8 ;  // start j
		let ret = "" ;
		for( j = sj; j < c; ++j ) {
			for( i = (j==sj)?si:0; i < 8; ++i ) {
				if( G[ j ][ i ] < 16 )
					ret += '0' ; 
				ret += G[ j ][ i ].toString( 16 ).toUpperCase() ;
			}
		}
		return ret ;
	}

	const writeSize = function( bitLength ) {
		// 96 bit length little endian
		G[ c - 2 ][ 4 ] = bitLength & 0xFF ;
		G[ c - 2 ][ 5 ] = ( bitLength >>> 8  ) & 0xFF ;
		G[ c - 2 ][ 6 ] = ( bitLength >>> 16 ) & 0xFF ;
		G[ c - 2 ][ 7 ] = ( bitLength >>> 24 ) & 0xFF ;
		G[ c - 1 ][ 0 ] = 0 ;  // ( bitLength >>> 32 ) & 0xFF ;
		G[ c - 1 ][ 1 ] = 0 ;  // ( bitLength >>> 40 ) & 0xFF ;
		G[ c - 1 ][ 2 ] = 0 ;  // ( bitLength >>> 48 ) & 0xFF ;
		G[ c - 1 ][ 3 ] = 0 ;  // ( bitLength >>> 56 ) & 0xFF ;
		G[ c - 1 ][ 4 ] = 0 ;  // ( bitLength >>> 64 ) & 0xFF ;
		G[ c - 1 ][ 5 ] = 0 ;  // ( bitLength >>> 72 ) & 0xFF ;
		G[ c - 1 ][ 6 ] = 0 ;  // ( bitLength >>> 80 ) & 0xFF ;
		G[ c - 1 ][ 7 ] = 0 ;  // ( bitLength >>> 88 ) & 0xFF ;
	}
	
	const incCell = function() {
		++row ;
		if( row >= 8 ) {
			row = 0 ;
			++col ;
			if( col >= c ) {
				col = 0 ;
				W = hv() ;
				for( j = 0; j < c; ++j ) {
					G[ j ]  = [ 0, 0, 0, 0, 0, 0, 0, 0 ] ;
				}
			}
		}
	}

	const appendByte = function( b ) {
		if( high ) {
			G[ col ][ row ] = b ;
			incCell() ;
		}
		else {
			G[ col ][ row ] += ( b >> 4 ) & 0xF ;
			incCell() ;
			G[ col ][ row ] = ( b & 0xF ) << 4 ;
		}
	}

	const appendHex = function( h ) {
		let y = h.charCodeAt( 0 ) ;
		if( y >= 48 && y <= 57 )       y = y - 48 ;  // 0-9 
		else if( y >= 65 && y <= 70 )  y = y - 55 ;  // A-F
		else if( y >= 97 && y <= 102 ) y = y - 87 ;  // a-f
		else throw "Invalid hexadecimal symbol: " + h ;
				
		if( high ) {
			G[ col ][ row ] = y << 4 ;
		}
		else {
			G[ col ][ row ] += y ;
			incCell() ;
		}
		high = ! high ;
	}

	const freeBits = function() {
		return ( ( c - col - 1 ) * 8 + ( 8 - row ) ) * 8 - ( high ? 0 : 4 ) ;
	}

	const procUtf8 = function( message ) {
		init() ;
		let bitLength = 0 ;
		let pos = 0 ;
		i = j = 0 ;
		while( pos < message.length ) {
			let c = message.charCodeAt( pos ) ;
			if( c < 0x80 ) {  // one-byte symbol
				appendByte( c ) ;
				bitLength += 8 ;
			}
			else if( c < 0x800 ) {  // two-byte symbol
				appendByte( 0xc0 | ( c >> 6   ) ) ;
				appendByte( 0x80 | ( c & 0x3F ) ) ;
				bitLength += 16 ;
			}
			else if( c < 0xD800 || c >= 0xE000 ) {  // three-byte symbol
				appendByte( 0xE0 | ( c >> 12 ) ) ;
				appendByte( 0x80 | ( ( c >> 6 ) & 0x3F ) ) ;
				appendByte( 0x80 | ( c & 0x3F ) ) ;
				bitLength += 24 ;
			}
			else {  // surrogate pair - next symbol should be included
				++pos ;
				c = 0x10000 + ( ( ( c & 0x3FF ) << 10 ) | ( message.charCodeAt( pos ) & 0x3FF ) ) ;
				appendByte( 0xF0 | ( c >> 18 ) ) ;
				appendByte( 0x80 | ( ( c >> 12 ) & 0x3F ) ) ;
				appendByte( 0x80 | ( ( c >> 6 ) & 0x3F ) ) ;
				appendByte( 0x80 | ( c & 0x3F ) ) ;
				bitLength += 32 ;
			}
			++pos ;
		}
		appendByte( 0x80 ) ;
		if( freeBits() < 96 ) {
			W = hv() ;
			for( j = 0; j < c; ++j ) {
				G[ j ]  = [ 0, 0, 0, 0, 0, 0, 0, 0 ] ;
			}
		}
		writeSize( bitLength ) ;
		W = hv() ;
		return rln() ;
	}
    
    const P = [1,2,4,8,16,32,64,128,29,58,116,232,205,135,19,38,76,152,45,90,180,117,234,201,143,3,6,12,24,48,96,192,157,39,78,156,37,74,148,53,106,212,181,119,238,193,159,35,70,140,5,10,20,40,80,160,93,186,105,210,185,111,222,161,95,190,97,194,153,47,94,188,101,202,137,15,30,60,120,240,253,231,211,187,107,214,177,127,254,225,223,163,91,182,113,226,217,175,67,134,17,34,68,136,13,26,52,104,208,189,103,206,129,31,62,124,248,237,199,147,59,118,236,197,151,51,102,204,133,23,46,92,184,109,218,169,79,158,33,66,132,21,42,84,168,77,154,41,82,164,85,170,73,146,57,114,228,213,183,115,230,209,191,99,198,145,63,126,252,229,215,179,123,246,241,255,227,219,171,75,150,49,98,196,149,55,110,220,165,87,174,65,130,25,50,100,200,141,7,14,28,56,112,224,221,167,83,166,81,162,89,178,121,242,249,239,195,155,43,86,172,69,138,9,18,36,72,144,61,122,244,245,247,243,251,235,203,139,11,22,44,88,176,125,250,233,207,131,27,54,108,216,173,71,142,1,2,4,8,16,32,64,128,29,58,116,232,205,135,19,38,76,152,45,90,180,117,234,201,143,3,6,12,24,48,96,192,157,39,78,156,37,74,148,53,106,212,181,119,238,193,159,35,70,140,5,10,20,40,80,160,93,186,105,210,185,111,222,161,95,190,97,194,153,47,94,188,101,202,137,15,30,60,120,240,253,231,211,187,107,214,177,127,254,225,223,163,91,182,113,226,217,175,67,134,17,34,68,136,13,26,52,104,208,189,103,206,129,31,62,124,248,237,199,147,59,118,236,197,151,51,102,204,133,23,46,92,184,109,218,169,79,158,33,66,132,21,42,84,168,77,154,41,82,164,85,170,73,146,57,114,228,213,183,115,230,209,191,99,198,145,63,126,252,229,215,179,123,246,241,255,227,219,171,75,150,49,98,196,149,55,110,220,165,87,174,65,130,25,50,100,200,141,7,14,28,56,112,224,221,167,83,166,81,162,89,178,121,242,249,239,195,155,43,86,172,69,138,9,18,36,72,144,61,122,244,245,247,243,251,235,203,139,11,22,44,88,176,125,250,233,207,131,27,54,108,216,173,71,142,1];
    const R = [0,0,1,25,2,50,26,198,3,223,51,238,27,104,199,75,4,100,224,14,52,141,239,129,28,193,105,248,200,8,76,113,5,138,101,47,225,36,15,33,53,147,142,218,240,18,130,69,29,181,194,125,106,39,249,185,201,154,9,120,77,228,114,166,6,191,139,98,102,221,48,253,226,152,37,179,16,145,34,136,54,208,148,206,143,150,219,189,241,210,19,92,131,56,70,64,30,66,182,163,195,72,126,110,107,58,40,84,250,133,186,61,202,94,155,159,10,21,121,43,78,212,229,172,115,243,167,87,7,112,192,247,140,128,99,13,103,74,222,237,49,197,254,24,227,165,153,119,38,184,180,124,17,68,146,217,35,32,137,46,55,63,209,91,149,188,207,205,144,135,151,178,220,252,190,97,242,86,211,171,20,42,93,158,132,60,57,83,71,109,65,162,31,45,67,216,183,123,164,118,196,23,73,236,127,12,111,246,108,161,59,82,41,157,85,170,251,96,134,177,187,204,62,90,203,89,95,176,156,169,160,81,11,245,22,235,122,117,44,215,79,174,213,233,230,231,173,232,116,214,244,234,168,80,88,175];
	const S = [] ;
    S[0] = S[4] = [168,67,95,6,107,117,108,89,113,223,135,149,23,240,216,9,109,243,29,203,201,77,44,175,121,224,151,253,111,75,69,57,62,221,163,79,180,182,154,14,31,191,21,225,73,210,147,198,146,114,158,97,209,99,250,238,244,25,213,173,88,164,187,161,220,242,131,55,66,228,122,50,156,204,171,74,143,110,4,39,46,231,226,90,150,22,35,43,194,101,102,15,188,169,71,65,52,72,252,183,106,136,165,83,134,249,91,219,56,123,195,30,34,51,36,40,54,199,178,59,142,119,186,245,20,159,8,85,155,76,254,96,92,218,24,70,205,125,33,176,63,27,137,255,235,132,105,58,157,215,211,112,103,64,181,222,93,48,145,177,120,17,1,229,0,104,152,160,197,2,166,116,45,11,162,118,179,190,206,189,174,233,138,49,28,236,241,153,148,170,246,38,47,239,232,140,53,3,212,127,251,5,193,94,144,32,61,130,247,234,10,13,126,248,80,26,196,7,87,184,60,98,227,200,172,82,100,16,208,217,19,12,18,41,81,185,207,214,115,141,129,84,192,237,78,68,167,42,133,37,230,202,124,139,86,128];
    S[1] = S[5] = [206,187,235,146,234,203,19,193,233,58,214,178,210,144,23,248,66,21,86,180,101,28,136,67,197,92,54,186,245,87,103,141,49,246,100,88,158,244,34,170,117,15,2,177,223,109,115,77,124,38,46,247,8,93,68,62,159,20,200,174,84,16,216,188,26,107,105,243,189,51,171,250,209,155,104,78,22,149,145,238,76,99,142,91,204,60,25,161,129,73,123,217,111,55,96,202,231,43,72,253,150,69,252,65,18,13,121,229,137,140,227,32,48,220,183,108,74,181,63,151,212,98,45,6,164,165,131,95,42,218,201,0,126,162,85,191,17,213,156,207,14,10,61,81,125,147,27,254,196,71,9,134,11,143,157,106,7,185,176,152,24,50,113,75,239,59,112,160,228,64,255,195,169,230,120,249,139,70,128,30,56,225,184,168,224,12,35,118,29,37,36,5,241,110,148,40,154,132,232,163,79,119,211,133,226,82,242,130,80,122,47,116,83,179,97,175,57,53,222,205,31,153,172,173,114,44,221,208,135,190,94,166,236,4,198,3,52,251,219,89,182,194,1,240,90,237,167,102,33,127,138,39,199,192,41,215];
    S[2] = S[6] = [147,217,154,181,152,34,69,252,186,106,223,2,159,220,81,89,74,23,43,194,148,244,187,163,98,228,113,212,205,112,22,225,73,60,192,216,92,155,173,133,83,161,122,200,45,224,209,114,166,44,196,227,118,120,183,180,9,59,14,65,76,222,178,144,37,165,215,3,17,0,195,46,146,239,78,18,157,125,203,53,16,213,79,158,77,169,85,198,208,123,24,151,211,54,230,72,86,129,143,119,204,156,185,226,172,184,47,21,164,124,218,56,30,11,5,214,20,110,108,126,102,253,177,229,96,175,94,51,135,201,240,93,109,63,136,141,199,247,29,233,236,237,128,41,39,207,153,168,80,15,55,36,40,48,149,210,62,91,64,131,179,105,87,31,7,28,138,188,32,235,206,142,171,238,49,162,115,249,202,58,26,251,13,193,254,250,242,111,189,150,221,67,82,182,8,243,174,190,25,137,50,38,176,234,75,100,132,130,107,245,121,191,1,95,117,99,27,35,61,104,42,101,232,145,246,255,19,88,241,71,10,127,197,167,231,97,90,6,70,68,66,4,160,219,57,134,84,170,140,52,33,139,248,12,116,103];
    S[3] = S[7] = [104,141,202,77,115,75,78,42,212,82,38,179,84,30,25,31,34,3,70,61,45,74,83,131,19,138,183,213,37,121,245,189,88,47,13,2,237,81,158,17,242,62,85,94,209,22,60,102,112,93,243,69,64,204,232,148,86,8,206,26,58,210,225,223,181,56,110,14,229,244,249,134,233,79,214,133,35,207,50,153,49,20,174,238,200,72,211,48,161,146,65,177,24,196,44,113,114,68,21,253,55,190,95,170,155,136,216,171,137,156,250,96,234,188,98,12,36,166,168,236,103,32,219,124,40,221,172,91,52,126,16,241,123,143,99,160,5,154,67,119,33,191,39,9,195,159,182,215,41,194,235,192,164,139,140,29,251,255,193,178,151,46,248,101,246,117,7,4,73,51,228,217,185,208,66,199,108,144,0,142,111,80,1,197,218,71,63,205,105,162,226,122,167,198,147,15,10,6,230,43,150,163,28,175,106,18,132,57,231,176,130,247,254,157,135,92,129,53,222,180,165,252,128,239,203,187,107,118,186,90,125,120,11,149,227,173,116,152,59,54,100,109,220,240,89,169,76,23,127,145,184,201,87,27,224,97];
    const v = [ 1, 1, 5, 1, 8, 6, 7, 4 ] ;
	const shift=[ 0, 1, 2, 3, 4, 5, 6, ( L == 1024 ? 11 : 7 ) ] ;
	const M = (x, y) => (x == 0 || y == 0 ) ? 0 : P[ R[x] + R[y] ] ;
}
